# Default values for kube-assist operator
# This is a YAML-formatted file.

# Number of operator replicas. Only 1 replica is needed when leader election
# is enabled (the default). Increase for HA if desired.
replicaCount: 1

# Number of old ReplicaSets to retain for rollback.
revisionHistoryLimit: 3

image:
  repository: ghcr.io/osagberg/kube-assist-operator
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created.
  create: true
  # Automatically mount the ServiceAccount API credentials into the pod.
  automount: true
  # Annotations to add to the service account (e.g. for workload identity).
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template.
  name: ""

podAnnotations: {}

podLabels: {}

# Pod-level security context. Applied to all containers in the pod.
podSecurityContext:
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

# Container-level security context for the manager container.
securityContext:
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL

# Operator-specific settings
operator:
  # Enable leader election for controller manager.
  # Required when running multiple replicas.
  leaderElection:
    enabled: true
  # Health probe bind address. Set to "0" to disable.
  healthProbeBindAddress: ":8081"
  # Metrics bind address. Set to "0" to disable metrics.
  metricsBindAddress: ":8080"

# Metrics service settings.
metrics:
  service:
    # Enable a Service for the metrics endpoint (port 8080).
    # Useful for Prometheus ServiceMonitor discovery.
    enabled: false
    # Service type: ClusterIP, NodePort, or LoadBalancer.
    type: ClusterIP
    # Service port (external).
    port: 8080
    # Annotations to add to the metrics service (e.g. for Prometheus scraping).
    annotations: {}

# ServiceMonitor for Prometheus Operator scrape configuration.
serviceMonitor:
  # Enable ServiceMonitor creation. Requires metrics.service.enabled=true.
  enabled: false
  # Namespace for the ServiceMonitor (defaults to release namespace).
  namespace: ""
  # Additional labels for the ServiceMonitor (e.g. for Prometheus selector matching).
  labels: {}
  # Scrape interval.
  interval: 30s
  # Scrape timeout.
  scrapeTimeout: 10s

# PrometheusRule for alerting rules.
prometheusRule:
  # Enable PrometheusRule creation.
  enabled: false
  # Namespace for the PrometheusRule (defaults to release namespace).
  namespace: ""
  # Additional labels for the PrometheusRule.
  labels: {}
  # Severity labels for built-in alerts. Override per-alert severity here.
  alertSeverity:
    aiDegraded: warning
    reconcileErrors: warning
    budgetNearLimit: info
  # Additional custom alerting rules appended to the built-in rules group.
  additionalRules: []
  # - alert: MyCustomAlert
  #   expr: kubeassist_issues_total > 100
  #   for: 5m
  #   labels:
  #     severity: critical
  #   annotations:
  #     summary: "Too many issues"

# Grafana dashboard ConfigMap for sidecar auto-discovery.
grafana:
  # Enable Grafana dashboard ConfigMap creation.
  enabled: false
  # Namespace for the ConfigMap (defaults to release namespace).
  namespace: ""
  # Additional labels for the ConfigMap.
  labels: {}
  # Annotations for the ConfigMap.
  annotations: {}
  # Grafana sidecar settings.
  sidecar:
    # Label the sidecar watches for dashboard auto-discovery.
    label: grafana_dashboard

# Dashboard settings for the Team Health web UI.
dashboard:
  # Enable the Team Health Dashboard web server.
  enabled: false
  # Dashboard bind address (port the dashboard listens on).
  bindAddress: ":9090"
  # Bearer token for authenticating mutating API requests.
  # If empty, mutating endpoints are unprotected (a warning is logged).
  # If set, TLS cert/key is required unless allowInsecureHttp=true.
  authToken: ""
  # Allow auth over plain HTTP (local/dev only). Ignored when authToken is empty.
  allowInsecureHttp: false
  # Maximum number of concurrent SSE client connections.
  # Excess connections are rejected with HTTP 503. Set to 0 for unlimited.
  maxSSEClients: 100
  # Health check polling interval (Go duration string, e.g. "30s", "1m").
  checkInterval: "30s"
  # SSE client channel buffer capacity.
  sseBufferSize: 10
  # Health history ring buffer capacity (number of snapshots retained).
  historySize: 100
  # Reference to a Secret containing the auth token.
  # If set, takes precedence over authToken.
  authTokenSecretRef:
    name: ""
    key: "auth-token"
  # TLS settings for HTTPS dashboard.
  tls:
    # Enable TLS for the dashboard server.
    enabled: false
    # Name of a Secret containing tls.crt and tls.key.
    secretName: ""
  # Dashboard service settings.
  service:
    # Service type: ClusterIP, NodePort, or LoadBalancer.
    type: ClusterIP
    # Service port (external).
    port: 9090

# AI-powered suggestions settings.
# When enabled, health check issues include AI-generated remediation suggestions.
ai:
  # Enable AI-powered suggestions for health check issues.
  enabled: false
  # AI provider: "anthropic" (Claude), "openai", or "noop".
  provider: "noop"
  # AI model to use. Leave empty for the provider's default model.
  model: ""
  # API key secret reference (recommended over plain text).
  apiKeySecretRef:
    # Name of the Kubernetes Secret containing the API key.
    name: ""
    # Key within the secret that holds the API key value.
    key: "api-key"
  # Optional cheaper model for AI explain/narrative mode.
  explainModel: ""
  # AI analysis context timeout (Go duration string, e.g. "90s", "2m").
  analysisTimeout: "90s"
  # Maximum issues sent to AI per batch.
  maxIssuesPerBatch: 15
  # Token budget limits (0 = unlimited).
  budget:
    dailyTokenLimit: 0
    monthlyTokenLimit: 0
  # Log/event context for AI analysis. When enabled, recent events and pod
  # logs are included with issues sent to AI for richer root cause analysis.
  logContext:
    enabled: false
    maxEventsPerIssue: 10
    maxLogLines: 50
    maxTotalChars: 30000

# DataSource backend settings.
# Use "kubernetes" (default) for local cluster or "console" for cross-cluster
# monitoring via a console backend HTTP API.
datasource:
  # Backend type: "kubernetes" or "console".
  type: "kubernetes"
  # Console backend URL (required when type=console).
  consoleURL: ""
  # Cluster identifier sent to the console backend (required when type=console).
  clusterID: ""
  # Bearer token for authenticating with the console backend.
  # If empty, no Authorization header is sent.
  bearerToken: ""
  # Reference to a Secret containing the bearer token.
  # If set, takes precedence over bearerToken.
  bearerTokenSecretRef:
    name: ""
    key: "bearer-token"

# Notification dispatch settings.
notifications:
  # Maximum number of concurrent notification dispatches (goroutine semaphore).
  semaphoreCapacity: 5

resources:
  limits:
    cpu: 500m
    memory: 256Mi
  requests:
    cpu: 10m
    memory: 64Mi

# Liveness probe configuration. The operator exposes /healthz on the health port.
livenessProbe:
  httpGet:
    path: /healthz
    port: 8081
  initialDelaySeconds: 15
  periodSeconds: 20
  timeoutSeconds: 3

# Readiness probe configuration. The operator exposes /readyz on the health port.
readinessProbe:
  httpGet:
    path: /readyz
    port: 8081
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 3

nodeSelector: {}

tolerations: []

affinity: {}
  # Example: spread operator pods across nodes for HA:
  # podAntiAffinity:
  #   preferredDuringSchedulingIgnoredDuringExecution:
  #     - weight: 100
  #       podAffinityTerm:
  #         labelSelector:
  #           matchLabels:
  #             app.kubernetes.io/name: kube-assist
  #         topologyKey: kubernetes.io/hostname

# Topology spread constraints for pod scheduling.
topologySpreadConstraints: []
# - maxSkew: 1
#   topologyKey: kubernetes.io/hostname
#   whenUnsatisfiable: DoNotSchedule
#   labelSelector:
#     matchLabels: {}

# Additional environment variables for the manager container.
env: []
# - name: MY_VAR
#   value: "my-value"

# Additional volumes to attach to the pod.
volumes: []

# Additional volume mounts for the manager container.
volumeMounts: []

# Priority class name for the pod.
priorityClassName: ""

# Termination grace period in seconds.
terminationGracePeriodSeconds: 10

# Network policy settings.
networkPolicy:
  # Enable network policy for the operator pod.
  # Controls ingress (health/metrics/dashboard) and egress (DNS, K8s API, AI APIs).
  enabled: true
  # Ingress mode: "permissive" (allow from all) or "strict" (restrict to specified selectors)
  ingressMode: strict
  # Pod selectors allowed to reach the operator in strict mode.
  # Only used when ingressMode=strict.
  # Default selectors for strict ingress mode.
  # Allows Prometheus scraping and kube-system access.
  ingressSelectors:
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: prometheus
      namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: monitoring
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
  # DNS egress mode: "all" (any namespace) or "kube-system" (restricted to kube-system pods).
  dnsMode: kube-system
  # Console backend egress (used when datasource.type=console).
  consoleEgress:
    # CIDR must be explicitly set when datasource.type=console.
    # Helm will fail-fast if console mode is enabled without a CIDR.
    # Example: "203.0.113.0/24"
    cidr: ""
    port: 443
